<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伍阿哥</title>
  <subtitle>紫薇，快到我碗里来~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wuage.me/"/>
  <updated>2016-09-07T06:05:05.255Z</updated>
  <id>http://wuage.me/</id>
  
  <author>
    <name>伍阿哥</name>
    <email>wu_zhuojun@sina.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何正确选择云服务？|创业公司做产品的感想</title>
    <link href="http://wuage.me/2016/09/07/IT-think-cloud/"/>
    <id>http://wuage.me/2016/09/07/IT-think-cloud/</id>
    <published>2016-09-06T16:00:00.000Z</published>
    <updated>2016-09-07T06:05:05.255Z</updated>
    
    <content type="html"><![CDATA[<p>经常有朋友谈到，现在互联网做产品更多的不是自己搭建机房而是采用云服务，来加速产品的迭代开发。<br>但问题是，现在市面上那么多的云服务，我们该如何做出正确的选择，变得特别重要。</p>
<p>那么我们就从价格、产品、技术支持的多个维度来分析国内外云服务的特点。<br>微软云，更适合国有企业、政府。价格高但提供的服务质量更好、24小时的技术支持。微软的基因决定了它的产品意识形态，更多的是为企业服务。<br>亚马逊，同时价格也贵，国内有部分互联网企业喜欢亚马逊是因为它能够提供更专业的多元化的云服务。</p>
<p>有人担心说国内的计算机技术比不上国外，那么云计算是不是也跟国外有差距。首先，我认为国内的云已经做的相当好，技术成熟、产品全面，能够满足大部分企业的需求，各种云服务在国内大放异彩，竞相争夺市场份额。</p>
<p>国内大部分互联网创业公司更喜欢阿里云，因为它的入门门槛低，价格优惠，云服务全面。并且阿里云的产品风格有点像是模仿亚马逊，相当于是把亚马逊的云做了本土化运营。<br>阿里云占据了国内云市场的半壁江山。剩余的口碑较好，占有一定市场份额的是腾讯云、UCloud、青云。</p>
<p>像以上几个公司都能提供非常全面的云服务产品，从基础的设备服务如：主机的计算能力、网络带宽、文件存储、数据库，再到应用服务如：账号接入、搜索服务、大数据分析服务等等。都非常全面。<br>而且为什么国外云提供如此优质的云服务的情况下，阿里、腾讯能够在国内能占有那么大的市场份额的主要原因还是本土化运营。比如，最近视频直播火了，阿里和腾讯就会提供直播云。他们更了解国内市场，提供更接地气的云服务。</p>
<p>腾讯云的特点是与腾讯自身产品的结合，提供社交入口。用户账号系统接入是它的一个卖点。同样它提供的云服务也是非常全面。<br>UCloud和青云的特点是产品线虽然没有阿里和腾讯的丰富，但我能提供更好的技术支持，像阿里云和腾讯的工单处理基本要等十多分钟才有回复，有时候会更久。<br>这对于产品快速迭代的互联网创业公司来说是一个痛点。而UCloud和青云正好是抓住了这个痛点，我提供不了更全面的云服务，那么我就用更好技术支持来弥补。<br>另外，百度云、京东云、新浪云、360云等大公司的云服务有点边缘化。<br>百度云曾经是提供了关于自身产品的一系列云服务，比如地图、搜索、大数据处理，但最近一两年也没有大力发展，貌似被阿里、腾讯甩在后面。<br>京东云更多也是提供自身产品相关的云服务，比如电商云、金融云。<br>360提供的安全云主机。</p>
<p>华为最近半年大力发展云服务，在技术社区经常能看到他的宣传，它举办的云相关的技术竞赛。表明了它准备要抢占国内云市场的决心。<br>它的特点更多是针对企业提供云服务解决方案，跟其他云不一样，其他云更多是提供基础服务，客户自身来选择服务来搭建系统。<br>华为更多是B2B的模式，针对一个企业来制定整套的解决方案。因此华为云更适合有一定规模和经济基础的公司。</p>
<p>还有其他的云服务商更多是提供细分市场的云服务，比如七牛、又拍云的云存储、CDN。<br>还有一些APP推送云、数据统计、APP测试云、后端云等。</p>
<p>如何选择云这个跟你的项目背景有关，不同的企业，不同的产品，不同的发展阶段，都有不一样的决策。<br>在了解了各个云服务的优缺点之后，根据自身的需要去选择更适合自己的云服务。<br><strong>没有更好的云，只有更适合自己的云。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常有朋友谈到，现在互联网做产品更多的不是自己搭建机房而是采用云服务，来加速产品的迭代开发。&lt;br&gt;但问题是，现在市面上那么多的云服务，我们该如何做出正确的选择，变得特别重要。&lt;/p&gt;
&lt;p&gt;那么我们就从价格、产品、技术支持的多个维度来分析国内外云服务的特点。&lt;br&gt;微软云
    
    </summary>
    
      <category term="创业公司做产品的感想" scheme="http://wuage.me/categories/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%81%9A%E4%BA%A7%E5%93%81%E7%9A%84%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="创业公司做产品的感想" scheme="http://wuage.me/tags/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%81%9A%E4%BA%A7%E5%93%81%E7%9A%84%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Template模式</title>
    <link href="http://wuage.me/2016/09/03/oop-template/"/>
    <id>http://wuage.me/2016/09/03/oop-template/</id>
    <published>2016-09-02T16:00:00.000Z</published>
    <updated>2016-09-03T01:29:37.220Z</updated>
    
    <content type="html"><![CDATA[<p>其实所有设计模式都是有EIT结构组成，EIT就好比原子，具体的模式好比分子，分子由原子组成。</p>
<p>比如现在要画两幅画，这两幅画的背景都是蓝天白云，其中一幅画的前景是海鸥，<br>另外一幅画的前景是风筝。那么应该把不变的部分提取到父类，也就是把背景提取到父类，变化的部分放到子类。</p>
<pre><code>public class E
{
    public void  draw()
    {
        //蓝天白云
    }
}

public class T extends E
{
    public void draw()
    {
        draw();
        //海鸥
    }
}

//客户端代码
public class Client
{
    public void main()
    {
        E e = new T();
        e.draw();
    }
}
</code></pre><p>当调用e.draw(); 时会首先调用父类的 draw 再调用子类的 draw。<br>这是一种实现方式，但这种方式有个缺点就是，子类与父类有较大的依赖，父类的 draw方法被调用后，后面改版，维护的成本就大了。我们可以使用另外一种方式来实现就是<br>Template Month模式。</p>
<p>Template Method模式：</p>
<pre><code>public class E
{
    public draw()   
    {
        //蓝天白云
        onDraw();
    }
    public void abstract onDraw();
}

public class T extends E
{
    public void onDraw()
    {
        //海鸥
    }   
}    


//客户端代码
public class Client
{
    public void main()
    {
        E e = new T();
        e.draw();
    }
}
</code></pre><p>这种由客户端代码来调用E的实体函数，再通过接口控制反转来执行T的 onDraw()<br>这种模式叫 TM模式。其中E的draw() 方法是叫 template方法，onDraw()叫 hook方法</p>
<p>TM设计模式虽然已经很优秀了，但仍然有个不好的地方，就是 Client 这里会用到 E 这个父类，那么当有很多Client （客户端用户不止一个厂商）使用了E，是的E变化的自由度就变低了，解决办法如下。</p>
<p>Template Month模式：</p>
<pre><code>interface I
{
    public void  draw();
}


public class E implements  I
{
    public void draw()   
    {
        //蓝天白云
        onDraw();
    }
    public void abstract onDraw();
}

public class T extends E
{
    public void onDraw()
    {
        //海鸥
    }   
}    


//客户端代码
public class Client
{
    public void main()
    {
        I e = new T();
        e.draw();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实所有设计模式都是有EIT结构组成，EIT就好比原子，具体的模式好比分子，分子由原子组成。&lt;/p&gt;
&lt;p&gt;比如现在要画两幅画，这两幅画的背景都是蓝天白云，其中一幅画的前景是海鸥，&lt;br&gt;另外一幅画的前景是风筝。那么应该把不变的部分提取到父类，也就是把背景提取到父类，变化的
    
    </summary>
    
      <category term="架构设计" scheme="http://wuage.me/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="面向对象，架构设计" scheme="http://wuage.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>老司机教你如何建博客</title>
    <link href="http://wuage.me/2016/08/31/hexo-blog/"/>
    <id>http://wuage.me/2016/08/31/hexo-blog/</id>
    <published>2016-08-30T16:00:00.000Z</published>
    <updated>2016-08-31T13:49:03.199Z</updated>
    
    <content type="html"><![CDATA[<p>有人说博客早就过时了，现在都玩微信、微博。<br>那么还有必要花这么大的精力来经营自己的博客呢？关于这个话题由知乎的牛人来给你解答。<br><a href="https://zhuanlan.zhihu.com/p/19743861" target="_blank" rel="external">为什么你要写博客？</a></p>
<p>而我做的博客的想法很简单，就是在个自由的地方表达自己的想法，有关工作、生活、创业、理想。</p>
<p>本文教大家如何用hexo一步步来搭建个人博客。（Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架–极客精神）</p>
<p>1、购买一个域名，可以在<a href="https://wanwang.aliyun.com/" target="_blank" rel="external">万网</a>选购，一般只需要花个几十块钱就能用一年。<br>2、在Github上创建一个page项目，项目的名称格式是 yourname.github.io。yourname里面替换成你的github的用户名。比如我的网站地址就是 wuzhuojun.github.io（注意Github一定要绑定邮箱否则会有问题）<br>3、在万网后台把域名设置IP解析，IP地址你可以 ping yourname.github.io来获取。<br>4、在page项目上创建一个文件名字为CNAME，文件的内容写上你的域名，比如我的 wwww.wuage.me<br>5、访问www.wuage.me成功，表示你的github page搭建成功，下一步搭建hexo。<br>6、安装node.js环境，步骤网上找。<br>7、安装hexo，用Git Bash执行mkdir hexo;cd hexo; npm install -g hexo; hexo init ;hexo g; hexo s;访问<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 显示正常，表示本地hexo系统安装成功。hexo g表示生成html网页，hexo s表示启动本地web服务。<br>8、打开站点配置文件 /_config.yml 添加以下内容，表示你要把写好的博客上传到对应的github项目</p>
<pre><code>deploy: 
    type: git
    repository: git@github.com:wuzhuojun/wuzhuojun.github.io.git
    branch: master
</code></pre><p>9、执行hexo d命令，将网页部署到github上，再次访问博客域名，就能成功显示hexo博客。（注意每次执行hexo d时都会把page项目中的CNAME文件删掉，有一个技巧就是将CNAME文件放到/source目录下就OK）<br>10、介绍下hexo的目录结构，source是存放博客文件，日志用markdown格式写的。/source/_config.yml是站点配置文件用于配置网站相关信息。themes是存放网站的主题的脚本，这里面的_config.yml是配置主题的配置文件。hexo非常好的一点就是官方提供很多主题让你选择。<br>11、给博客安装Next主题，执行命令git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> themes/next，在站点配置文件上修改为theme: next，至此你的博客搭建的差不多了。<br>12、接下来你可以为你网站添加更多功能，已经界面调成自己喜欢的样式。Next官网：<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">http://theme-next.iissnan.com/</a><br>13、markdown语法学习 <a href="https://www.zybuluo.com/" target="_blank" rel="external">https://www.zybuluo.com/</a><br>14、关于日志内容中的图片，建议可以用<a href="http://www.qiniu.com/" target="_blank" rel="external">七牛云存储</a>。<br>15、OK，已经弄好了，尽情享用吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有人说博客早就过时了，现在都玩微信、微博。&lt;br&gt;那么还有必要花这么大的精力来经营自己的博客呢？关于这个话题由知乎的牛人来给你解答。&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19743861&quot; target=&quot;_blank&quot; rel
    
    </summary>
    
      <category term="blog" scheme="http://wuage.me/categories/blog/"/>
    
    
      <category term="博客" scheme="http://wuage.me/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Android进阶练习一</title>
    <link href="http://wuage.me/2016/08/30/android-advanced-1/"/>
    <id>http://wuage.me/2016/08/30/android-advanced-1/</id>
    <published>2016-08-29T16:00:00.000Z</published>
    <updated>2016-08-30T14:57:38.211Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、有序广播：</strong><br><a href="https://github.com/wuzhuojun/BroadcastExample" target="_blank" rel="external">https://github.com/wuzhuojun/BroadcastExample</a></p>
<p>说明：<br>在manifest.xml设置的广播是静态注册，只要软件安装在手机上广播就能够生效。<br>用代码实现的是属于动态注册，只有软件启动后广播才能够生效。<br>除了能够接收系统的广播，也能够自定义广播。</p>
<p>Android的广播按照接收顺序分两种类型：无序广播和有序广播。<br>无序广播是所有注册者都能收到的广播。<br>有序广播是能够指定接收顺序，层层下达，能够设置接收者的优先级，优先级高的先收到而且能够把传递的数据进行修改。</p>
<p>另外广播还能够设置为本地广播，只能够是本进程才能收到的广播。</p>
<p><strong>2、定时任务（定时访问网络数据/闹钟）</strong><br><a href="https://github.com/wuzhuojun/AlarmService" target="_blank" rel="external">https://github.com/wuzhuojun/AlarmService</a><br>说明：<br>这是实现定时访问网络的一种手段，手机切换到后台仍然能够定时请求网络数据。可以作为消息通知拉数据的处理方式。</p>
<p>主要原理：<br>1、启动一个Service<br>2、Service使用AlarmManager启动定时闹钟<br>3、定时闹钟执行时发送一个广播事件<br>4、自定义的广播接收者收到广播后执行网络请求动作，再次启动Service 回到第1步，一直循环</p>
<p><strong>3、跨进程通信</strong><br><a href="https://github.com/wuzhuojun/AIDLService" target="_blank" rel="external">https://github.com/wuzhuojun/AIDLService</a><br>说明：<br>APP有时候需要调用第三方APP的服务，那么就要用到跨进程通信（IPC）。<br>由于是跨进程通信就要考虑到通信协议的问题，Android提供AIDL的解决方案。<br>APP请求方是客户端，APP被访问方是服务端。<br>首先要定义AIDL文件，编译后会生成接口文件（是一种代码自动生成的原理）<br>服务端注册远程服务，实现AIDL生成的接口并作为Binder对象返回。</p>
<p>客户端实现绑定服务，并定义ServiceConnection来接收服务端传过来的Binder引用，通过该引用能调用远程服务的功能。<br>需要注意的是，客户端的AIDL与服务端的AIDL文件的命名空间要一致，否则通信会失败。</p>
<p><strong>4、ListView + 下拉刷新 + 分页加载更多 + 数据缓存 + Fresco图片缓存组件</strong><br><a href="https://github.com/wuzhuojun/ListViewExample" target="_blank" rel="external">https://github.com/wuzhuojun/ListViewExample</a><br>说明：<br>使用PtrClassicFrameLayout组件来实现列表的下拉刷新，支持多种控件的下拉动作。<a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh" target="_blank" rel="external">https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh</a><br>判断列表滚动的位置来判断是否已经上拉到底部，然后执行分页加载。<br>网络请求用OKHttp <a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a><br>数据缓存用的是ACache，轻量级只有一个Java文件，你值得拥有。 <a href="https://github.com/yangfuhai/ASimpleCache" target="_blank" rel="external">https://github.com/yangfuhai/ASimpleCache</a></p>
<p><strong>5、把ListViewExample改造MVP模式，增加了单元测试的练习</strong><br><a href="https://github.com/wuzhuojun/MVPexample" target="_blank" rel="external">https://github.com/wuzhuojun/MVPexample</a><br>说明：<br>以往MVC模式下，Activity及承担了View的角色同时也要处理业务逻辑，代码变得很臃肿。<br>MVP模式把业务逻辑从Activity和Fragment拆分到Presenter。<br>流程是：<br>Activity/Fragment接收用户动作 =》 Presenter请求业务逻辑的调度 =》Model请求网络数据=》Model回调Presenter=》Presenter回调View=》View回调Activity/Fragment实现界面响应</p>
<p>由于View、Presenter、Model都有对应的接口实现因此能够执行一路往上的回调动作。<br>注意这里的Model是执行网络请求或者数据缓存的模块，而Bean是业务数据实体。</p>
<p>看了关于重构方面的书再次认识到单元测试的重要性，它能够帮你更高效的编写正确的生产代码。<br>执行单元测试时，看到一路的绿灯的感觉别提有多爽了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1、有序广播：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/wuzhuojun/BroadcastExample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/wuz
    
    </summary>
    
      <category term="移动开发" scheme="http://wuage.me/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="http://wuage.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://wuage.me/2016/08/29/oop-command/"/>
    <id>http://wuage.me/2016/08/29/oop-command/</id>
    <published>2016-08-28T16:00:00.000Z</published>
    <updated>2016-08-29T03:40:57.656Z</updated>
    
    <content type="html"><![CDATA[<p>背景简介：<br>开发软件，项目划分几个小组：需求组，美工组，代码组。<br>开发流程，客户提出需求=》需求分析=》美工设计界面=》写代码实现功能</p>
<pre><code>//项目小组抽象类
public abstract class Group
{
    public abstract void find();
    public abstract void add();
    public abstract void delete();
    public abstract void change();
    public abstract void action();
}

//需求组
public class XuqiuGroup extends Group
{
    public void find()
    {
        //找到需求人员
    }
    public void add()
    {
        //叫需求人员增加页面
    }
    public void delete()
    {
        //叫需求人员删除页面
    }
    public void change()
    {
        //叫需求人员修改页面
    }
    public void action()
    {
        //叫需求人员执行以上动作
    }
}

//美工组
public class MeigongGroup extends Group
{
    public void find()
    {
        //找到美工
    }
    public void add()
    {
        //叫美工增加页面
    }
    public void delete()
    {
        //叫美工删除页面
    }
    public void change()
    {
        //叫美工修改页面
    }
    public void action()
    {
        //叫美工执行以上动作
    }
}

//代码组
public class CodeGroup extends Group
{
    public void find()
    {
        //找到程序员
    }
    public void add()
    {
        //叫程序员增加页面
    }
    public void delete()
    {
        //叫程序员删除页面
    }
    public void change()
    {
        //叫程序员修改页面
    }
    public void action()
    {
        //叫程序员执行以上动作
    }
}


public class Client
{
    public void static main()
    {
        XuqiuGroup xg = new XuqiuGroup();
        xg.find();  //找到需求
        xg.add();   //增加一个页面
        xg.action();//给我去执行
        //找完需求后又去找美工再去找程序员。客户很累，发火了，你们给我一个接头人。
        //我不管你们内部如何实现，我只想告诉你们我想要什么，你们给我去做就行。
    }
}
</code></pre><p>客户的想法随时改变，一会增加功能、一会删除。然后，还得把想法跟每个组沟通。疲于奔命。<br>客户是甲方，他说这样修改需求太累了，我还得找这么多组的人来商量如何处理一个需求。<br>这样吧，你们找个接头人给我，我只需要把我的想法告诉他，至于内部怎么实现我不管，你们自己商量好如何去做。</p>
<p>于是，把客户的想法封装成一个个的命令，比如增加需求的命令 和 删除需求的命令。<br>再来找个接头人，让他把这个命令分发到每个组执行下去。</p>
<pre><code>public abstract class Command
{
    protected XuqiuGroup xg = new XuqiuGroup();
    protected MeigongGroup mg = new MeigongGroup();
    protected CodeGroup cg = new CodeGroup();
    public abstract void excute();  //你要我做什么我就做什么
}

//增加需求命令
public class AddXuqiuCommand extends Command
{
    //找到需求方 增加需求，再让美工 设计界面，最后让程序员实现功能
    public void excute()
    {
        xg.find();
        xg.add();
        xg.action();
        mg.find();
        mg.add();
        mg.action();
        cg.find();
        cg.add();
        cg.action();
    }
}

//删除需求命令
public class DelXuqiuCommand extends Command
{
    //找到需求方 删除需求，最后让程序员删除该功能
    public void excute()
    {
        xg.find();
        xg.add();
        xg.action();
        cg.find();
        cg.add();
        cg.action();
    }
}

//调度器 接头人
public class Invoker
{
    private Command command;
    //客户向我发出命令
    public void setCommand(Command command)
    {
        this.command = command;
    }
    //执行客户给的命令
    public void action()
    {
        command.excute();
    }
}

public class Client
{
    public static void main()
    {
        //接头人 你来给我执行一个 增加需求的命令
        Invoker invoker = new Invoker();
        invoker.setCommand(new AddXuqiuCommand());
        invoker.action();
        //接头人 你来给我执行一个 删除需求的命令
        invoker.setCommand(new DelXuqiuCommand());
        invoker.action();
    }
}
</code></pre><p>最终，这么实现就轻松很多了，客户不需要找到每个组下达命令。</p>
<p>但是，命令模式同时也有个缺点，当命令的组合情况复杂的时候，就是封装的命令就有很多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;背景简介：&lt;br&gt;开发软件，项目划分几个小组：需求组，美工组，代码组。&lt;br&gt;开发流程，客户提出需求=》需求分析=》美工设计界面=》写代码实现功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//项目小组抽象类
public abstract class Group
{
    publ
    
    </summary>
    
      <category term="架构设计" scheme="http://wuage.me/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="面向对象，架构设计" scheme="http://wuage.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="http://wuage.me/2016/08/28/oop-state/"/>
    <id>http://wuage.me/2016/08/28/oop-state/</id>
    <published>2016-08-27T16:00:00.000Z</published>
    <updated>2016-08-29T05:54:35.736Z</updated>
    
    <content type="html"><![CDATA[<p>我们开发项目的过程中通常会碰到一种需求，某个对象包含多种状态变化的可能性，随着状态的变化行为也执行不同的动作。<br><img src="http://o94lqiatj.bkt.clouddn.com/5533156.png" alt=""></p>
<p><strong>以电梯来举例：</strong><br>电梯最基本具备 开门、关门、上下走动、停止 这四种状态。状态与状态之间有约束的关系，比如只能在关门的情况下才能走动。<br>所以用传统面向过程的解决方案，就必须要用状态值来标记每一种状态，然后用多个if else语句来判断状态的执行顺序，每当增加一个新状态的时候就需要重新修改代码，这样就不符合开闭原则。</p>
<p>我们来看下如何用状态模式来优雅的处理问题。</p>
<pre><code>public abstract class LiftState
{
    protected Context context;
    public void setContext(Context context)
    {
        this.context = context;
    }
    public abstract void open();  //电梯开门
    public abstract void close(); //电梯关门
    public abstract void stop();  //电梯停止
    public abstract void run();   //电梯上下走动
}
//电梯处于开门状态
public class OpenState extends LiftState
{
    @Override
    public void open() {
        //本身就处于开门状态
        //do nothing
    }
    @Override
    public void close() {
        super.context.setLiftStatus(Context.closeState);  //切换至关门状态
        super.context.getLiftStatus().close(); //委托关门状态类 来执行具体的关门动作
    }
    @Override
    public void stop() {
        //电梯开门状态时，本身就停止的
        //do nothing
    }
    @Override
    public void run() {
        //电梯开门状态时，不能走动
        //do nothing
    }
}
//电梯走动状态
public class RunState extends LiftState
{
    @Override
    public void open() {
        //走动状态不能开门
        //do nothing
    }
    @Override
    public void close() {
        //走动状态本身就是处于关门状态
        //do nothing
    }
    @Override
    public void stop() {
        super.context.setLiftStatus(Context.stopState);  //切换至停止状态
        super.context.getLiftStatus().stop(); //委托停止状态类 来执行具体的停止动作
    }
    @Override
    public void run() {
        //本身就处于走动状态
        //do nothing
    }
}
//电梯关门状态类
public class CloseState extends LiftState
{
    @Override
    public void open() {
        super.context.setLiftStatus(Context.openStatus);  //切换至开门状态
        super.context.getLiftStatus().open(); //委托开门状态类 来执行具体的开门动作
    }
    @Override
    public void close() {
    }
    @Override
    public void stop() {
    }
    @Override
    public void run() {
        super.context.setLiftStatus(Context.runState);  //切换至走动状态
        super.context.getLiftStatus().run(); //委托走动状态类 来执行具体的走动动作
    }
}
//电梯停止状态类
public class StopState extends LiftState
{
    @Override
    public void open() {
        super.context.setLiftStatus(Context.openStatus);  //切换至开门状态
        super.context.getLiftStatus().open(); //委托开门状态类 来执行具体的走动动作
    }
    @Override
    public void close() {
    }
    @Override
    public void stop() {
    }
    @Override
    public void run() {
        super.context.setLiftStatus(Context.runState);  //切换至走动状态
        super.context.getLiftStatus().run(); //委托走动状态类 来执行具体的走动动作
    }
}
public class Context
{
    public final static OpenState openStatus = new OpenState();
    public final static CloseState closeState = new CloseState();
    public final static RunState runState = new RunState();
    public final static StopState stopState = new StopState();
    private LiftState curStatus; //当前电梯状态
    //设置电梯状态，并且把当前上下文的引用传递给具体的状态类，具体的状态类通过上下文的引用切换不同的状态。
    public void setLiftStatus(LiftState liftStatus)
    {
        curStatus = liftStatus;
        liftStatus.setContext(this);
    }
    //获取当前的电梯状态
    public LiftState getLiftStatus()
    {
        return curStatus;
    }
    public void open()
    {
        curStatus.open();
    }
    public void close()
    {
        curStatus.close();
    }
    public void stop()
    {
        curStatus.stop();
    }
    public void run()
    {
        curStatus.run();
    }
}
//客户端类
public class Client
{
    public static void main()
    {
        Context context = new Context();
        context.setLiftStatus(new CloseState());  //电梯初始化为关门状态
        context.open();
        context.close();
        context.run();
        context.stop();
    }
}
</code></pre><p><strong>需要说明的一点是：</strong><br>Context 是一个上下文角色，它的作用就是串联各个状态的过渡，在LifeState抽象类中我们定义了并把这个上下文组合进来，病传递到了子类。也就是四个具体状态类根据上下文的环境来决定如何进行状态的过渡。</p>
<p><strong>状态模式的优点：</strong><br>首先，每个状态类都很简洁，同时也不需要用 if else 来判断状态的切换。<br>同时，如果我们要新增状态只需要创建新的状态类即可，是通过扩展而非修改的方式来实现功能，这是面向对象的一个重要原则，开闭原则。非常完美。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们开发项目的过程中通常会碰到一种需求，某个对象包含多种状态变化的可能性，随着状态的变化行为也执行不同的动作。&lt;br&gt;&lt;img src=&quot;http://o94lqiatj.bkt.clouddn.com/5533156.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong
    
    </summary>
    
      <category term="架构设计" scheme="http://wuage.me/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="面向对象，架构设计" scheme="http://wuage.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="http://wuage.me/2016/08/27/oop-decorator/"/>
    <id>http://wuage.me/2016/08/27/oop-decorator/</id>
    <published>2016-08-26T16:00:00.000Z</published>
    <updated>2016-08-29T03:10:58.625Z</updated>
    
    <content type="html"><![CDATA[<p>装饰模式可以给我们很好的帮助，通过装饰模式重新封装一个类，而不是通过继承来完成，<br>简单点说，三个继承关系 Father,Son,GrandSon 三个类，我要再 Son 类上增强一些功能怎么办？<br>我想你会坚决的顶回去！不允许，对了，为什么呢？你增强的功能是修改 Son 类中的方法吗？增加方法吗 ？<br>对 GrandSon 的影响哪？特别是 GrandSon 有多个的情况，你怎么办？这个评估的工作量就是够你受的，所以这个是不允许的，那还是要解决问题的呀，怎么办？<br>通过建立 SonDecorator 类来修饰 Son，等于说是创建了一个新的类，这个对原有程序没有变更，通过扩充很好的完成了这次变更。</p>
<p>以煮咖啡为例：</p>
<pre><code>public abstract class Cafe
{
    public abstract void Cook(); //煮咖啡
}

//摩卡咖啡
public class MochaCafe extends Cafe
{
    public void Cook() {
    //煮摩卡咖啡
    }
}

//猫屎咖啡
public class CivetCoffee extends Cafe
{
    public void Cook() {
    //煮猫屎咖啡
    }
}

//带牛奶的摩卡咖啡
public class MilkMochaCafe extends MochaCafe
{
    public void AddMilk()
    {
        //加一些牛奶
    }

    public void Cook() {
        //煮猫屎咖啡
        super.Cook();
        //煮完以后 再加牛奶
        AddMilk();
    }
}

//带糖的猫屎咖啡
public class SugarCivetCoffee extends MochaCafe
{
    public void AddSugar()
    {
        //加一些糖
    }
    public void Cook() {
        //煮猫屎咖啡
        super.Cook();
        //煮完以后 再加一些糖
        AddSugar();
    }
}
</code></pre><p>咖啡的种类越来越多，配料的除了糖和牛奶 还 增加了蜂蜜等，继承关系变得越来越多。<br>继承关系越多系统架构越复杂，维护成本就会变高。<br>装饰者，通过组合方式来扩展功能，而非继承的方式。<br>我们来看下如何处理：</p>
<pre><code>//摩卡咖啡装饰者
public class CafeDecorator extends MochaCafe
{
    private MochaCafe mochaCafe;

    public CafeDecorator(MochaCafe mochaCafe) {
        this.mochaCafe = mochaCafe;
    }

    public void AddSugar()
    {
        //加一些糖
    }

    public void AddMilk()
    {
        //加牛奶
    }

    public void Cook()
    {
        super.Cook();
        AddSugar(); //煮咖啡之后加点糖
        AddMilk(); //煮咖啡之后加牛奶
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装饰模式可以给我们很好的帮助，通过装饰模式重新封装一个类，而不是通过继承来完成，&lt;br&gt;简单点说，三个继承关系 Father,Son,GrandSon 三个类，我要再 Son 类上增强一些功能怎么办？&lt;br&gt;我想你会坚决的顶回去！不允许，对了，为什么呢？你增强的功能是修改 
    
    </summary>
    
      <category term="架构设计" scheme="http://wuage.me/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="面向对象，架构设计" scheme="http://wuage.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="http://wuage.me/2016/08/26/oop-visitor/"/>
    <id>http://wuage.me/2016/08/26/oop-visitor/</id>
    <published>2016-08-25T16:00:00.000Z</published>
    <updated>2016-08-26T06:25:24.238Z</updated>
    
    <content type="html"><![CDATA[<p>访问者模式最常用的使用场景是统计功能（报表）、数据过滤功能（拦截器）、或者结合别的模式来使用（状态模式、代理模式等）<br>我们以统计功能举例来说明访问者模式的使用</p>
<p>核心是，分两个模块<br>一个模块负责数据的产生<br>一个模块负责遍历数据，展示数据。</p>
<p>我们先看下在不使用访问者模式的情况下的数据展示处理</p>
<pre><code>//员工
public abstract class Employee
{
    private int sex;
    private String name;
    private int age;
    private int money;

    public int getSex() {
        return sex;
    }

    public int getAge() {
        return age;
    }

    public int getMoney() {
        return money;
    }

    public void setSex(int sex) {
        this.sex = sex;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setMoney(int money) {
        this.money = money;
    }

    public abstract void getOtherInfo(); //输出别的一些内容

    public abstract void accept(IVisitor visitore);
}

//码农
public class CodeMan extends Employee
{
    private String code; //用的是什么类型的编程语言

    public void setCode(String code) {
        this.code = code;
    }

    @Override
    public void getOtherInfo() {
        //输出 code
    }

    //码农运行访问者访问
    @Override
    public void accept(IVisitor visitore) {
        visitore.visit(this);
    }
}

//美工妹纸
public class UIGirl extends Employee
{
    private String design; //设计UI图是用什么工具

    public void setDesign(String design) {
        this.design = design;
    }

    @Override
    public void getOtherInfo() {
        //输出 design
    }

    //美工妹纸运行访问者访问
    @Override
    public void accept(IVisitor visitore) {
        visitore.visit(this);
    }
}

//项目经理
public class Manager extends Employee
{
    private String manage; //用的是什么管理软件

    public void setManage(String manage) {
        this.manage = manage;
    }

    @Override
    public void getOtherInfo() {
        //输出 manage
    }

    //项目经理运行访问者访问
    @Override
    public void accept(IVisitor visitore) {
        visitore.visit(this);
    }
}


public interface IVisitor
{
    public void visit(Employee employee);
}

public class EmployeeVisitor implements IVisitor
{
    @Override
    public void visit(Employee employee) {
        report(employee);
    }

    public void report(Employee employee)
    {
        //获取了 员工的所有属性
        employee.getAge();
        employee.getMoney();
        employee.getName();
        employee.getOtherInfo();
        employee.getSex();

        //按照某种表格方式输出
    }
}


//客户端类
public class Client
{
    public void main()
    {
        ArrayList&lt;Employee&gt; employeeList = getEmployeeList();

        for (Employee item :employeeList) {
            item.accept(new EmployeeVisitor());
        }
    }


    public ArrayList&lt;Employee&gt; getEmployeeList()
    {
        ArrayList&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
        CodeMan zhangSan = new CodeMan();
        zhangSan.setAge(25);
        zhangSan.setSex(1);
        zhangSan.setName(&quot;张三&quot;);
        zhangSan.setMoney(5000);
        zhangSan.setCode(&quot;java&quot;);

        UIGirl lisi = new UIGirl();
        lisi.setAge(23);
        lisi.setSex(0);
        lisi.setName(&quot;李四&quot;);
        lisi.setMoney(5000);
        lisi.setDesign(&quot;PS&quot;);

        Manager wangWu = new Manager();
        wangWu.setAge(30);
        wangWu.setSex(1);
        wangWu.setName(&quot;王五&quot;);
        wangWu.setMoney(8000);
        wangWu.setManage(&quot;youdao&quot;);

        return employees;
    }
}
</code></pre><p>这样处理的时候是将数据模型和数据展示(report)都放在同一个模块实现。</p>
<p>我们来看下访问者模式是如何处理的。</p>
<pre><code>//员工
public abstract class Employee
{
    private int sex;
    private String name;
    private int age;
    private int money;

    public int getSex() {
        return sex;
    }

    public int getAge() {
        return age;
    }

    public int getMoney() {
        return money;
    }

    public void setSex(int sex) {
        this.sex = sex;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setMoney(int money) {
        this.money = money;
    }

    public abstract void getOtherInfo(); //输出别的一些内容

    public abstract void accept(IVisitor visitore);
}

//码农
public class CodeMan extends Employee
{
    private String code; //用的是什么类型的编程语言

    public void setCode(String code) {
        this.code = code;
    }

    @Override
    public void getOtherInfo() {
        //输出 code
    }

    //码农运行访问者访问
    @Override
    public void accept(IVisitor visitore) {
        visitore.visit(this);
    }
}

//美工妹纸
public class UIGirl extends Employee
{
    private String design; //设计UI图是用什么工具

    public void setDesign(String design) {
        this.design = design;
    }

    @Override
    public void getOtherInfo() {
        //输出 design
    }

    //美工妹纸运行访问者访问
    @Override
    public void accept(IVisitor visitore) {
        visitore.visit(this);
    }
}

//项目经理
public class Manager extends Employee
{
    private String manage; //用的是什么管理软件

    public void setManage(String manage) {
        this.manage = manage;
    }

    @Override
    public void getOtherInfo() {
        //输出 manage
    }

    //项目经理运行访问者访问
    @Override
    public void accept(IVisitor visitore) {
        visitore.visit(this);
    }
}


public interface IVisitor
{
    public void visit(Employee employee);
}

public class EmployeeVisitor implements IVisitor
{
    @Override
    public void visit(Employee employee) {
        report(employee);
    }

    public void report(Employee employee)
    {
        //获取了 员工的所有属性
        employee.getAge();
        employee.getMoney();
        employee.getName();
        employee.getOtherInfo();
        employee.getSex();

        //按照某种表格方式输出
    }
}


//客户端类
public class Client
{
    public void main()
    {
        ArrayList&lt;Employee&gt; employeeList = getEmployeeList();

        for (Employee item :employeeList) {
            item.accept(new EmployeeVisitor());
        }
    }


    public ArrayList&lt;Employee&gt; getEmployeeList()
    {
        ArrayList&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
        CodeMan zhangSan = new CodeMan();
        zhangSan.setAge(25);
        zhangSan.setSex(1);
        zhangSan.setName(&quot;张三&quot;);
        zhangSan.setMoney(5000);
        zhangSan.setCode(&quot;java&quot;);

        UIGirl lisi = new UIGirl();
        lisi.setAge(23);
        lisi.setSex(0);
        lisi.setName(&quot;李四&quot;);
        lisi.setMoney(5000);
        lisi.setDesign(&quot;PS&quot;);

        Manager wangWu = new Manager();
        wangWu.setAge(30);
        wangWu.setSex(1);
        wangWu.setName(&quot;王五&quot;);
        wangWu.setMoney(8000);
        wangWu.setManage(&quot;youdao&quot;);

        return employees;
    }
}
</code></pre><p><strong>执行流程：</strong><br>首先通过循环遍历所有元素；<br>其次，每个员工对象都定义了一个访问者；<br>再其次，员工对象把自己做为一个参数调用访问者 visit 方法；<br>然后，访问者调用自己内部的计算逻辑，计算出相应的数据和表格元素；<br>最后，访问者打印出报表和数据； </p>
<p>访问者模式将数据展示独立出来，这样做使得<strong>责任单一</strong></p>
<p><strong>访问者模式的优点</strong><br><strong>符合单一职责原则：</strong><br>凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。</p>
<p><strong>扩展性良好：</strong><br>元素类可以通过接受不同的访问者来实现对不同操作的扩展。<br>访问者模式的适用场景假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。<br>但是，访问者模式并不是那么完美，它也有着致命的缺陷：增加新的元素类比较困难。通过访问者模式的代码可以看到，在访问者类中，每一个元素类都有它对应的处理方法，也就是说，每增加一个元素类都需要修改访问者类（也包括访问者类的子类或者实现类），修改起来相当麻烦。也就是说，在元素类数目不确定的情况下，应该慎用访问者模式。所以，访问者模式比较适用于对已有功能的重构，比如说，一个项目的基本功能已经确定下来，元素类的数据已经基本确定下来不会变了，会变的只是这些元素内的相关操作，这时候，我们可以使用访问者模式对原有的代码进行重构一遍，这样一来，就可以在不修改各个元素类的情况下，对原有功能进行修改。</p>
<p><strong>总结</strong><br>正如《设计模式》的作者GoF对访问者模式的描述：大多数情况下，你并需要使用访问者模式，但是当你一旦需要使用它时，那你就是真的需要它了。当然这只是针对真正的大牛而言。在现实情况下（至少是我所处的环境当中），很多人往往沉迷于设计模式，他们使用一种设计模式时，从来不去认真考虑所使用的模式是否适合这种场景，而往往只是想展示一下自己对面向对象设计的驾驭能力。编程时有这种心理，往往会发生滥用设计模式的情况。所以，在学习设计模式时，一定要理解模式的适用性。必须做到使用一种模式是因为了解它的优点，不使用一种模式是因为了解它的弊端；而不是使用一种模式是因为不了解它的弊端，不使用一种模式是因为不了解它的优点。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;访问者模式最常用的使用场景是统计功能（报表）、数据过滤功能（拦截器）、或者结合别的模式来使用（状态模式、代理模式等）&lt;br&gt;我们以统计功能举例来说明访问者模式的使用&lt;/p&gt;
&lt;p&gt;核心是，分两个模块&lt;br&gt;一个模块负责数据的产生&lt;br&gt;一个模块负责遍历数据，展示数据。&lt;/p
    
    </summary>
    
      <category term="架构设计" scheme="http://wuage.me/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="面向对象，架构设计" scheme="http://wuage.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《无间道》观察者模式</title>
    <link href="http://wuage.me/2016/08/25/oop-observer/"/>
    <id>http://wuage.me/2016/08/25/oop-observer/</id>
    <published>2016-08-24T16:00:00.000Z</published>
    <updated>2016-08-25T05:41:15.772Z</updated>
    
    <content type="html"><![CDATA[<p>电影无间道很多人都看过，讲的是关于黑社会与警局卧底的故事。<br>我们今天就聊一下无间道和面向对象的观察者模式到底有什么关系。</p>
<pre><code>//被观察者
public interface Observable
{
    void notifyEverybody(); //通知所有人
}

//曾志伟 扮演的 黑社会老大 韩琛
public class HanLaoda implements Observable {
    ArrayList&lt;Observer&gt; observerList;//卧底们(除了梁朝伟还有很多卧底,比如陈朝伟、张朝伟)

    public void notifyEverybody()
    {
        for (Observer item : observerList) {
            item.reportWangSir();
        }
    }

    //韩老大为了扩充势力，只管招小弟进来，但他不知道招进来的是卧底
    public void addObserver(Observer observer)
    {
        observerList.add(observer);
    }

    //做违法事情
    public void doWeifa()
    {
        //卧底们一旦发现韩老大要做违法事情，就开始秘密通知警方
        notifyEverybody();
    }
}

//观察者
public interface Observer
{
    //卧底 一旦发现有违法交易，立马做出行动。报告给 黄秋生扮演的 王Sir。
    void reportWangSir();
}

//梁朝伟 扮演的 梁永仁 是警局安插到黑社会的卧底
public class LiangChaowei implements Observer
{
    public void reportWangSir()
    {
        //报告给王Sir
    }
}

//陈朝伟
public class ChenChaowei implements Observer
{
    public void reportWangSir()
    {
        //报告给王Sir
    }
}

//张朝伟
public class ZhangChaowei implements Observer
{
    public void reportWangSir()
    {
        //报告给王Sir
    }
}

public class Client
{
    public static void main()
    {
        HanLaoda han = new HanLaoda();
        //韩老大为了扩充势力，只管招小弟进来，但他不知道招进来的是卧底
        han.addObserver(new LiangChaowei());
        han.addObserver(new ChenChaowei());
        han.addObserver(new ZhangChaowei());

        //做违法事情
        han.doWeifa();
    }
}
</code></pre><p><strong>那观察者模式在什么情况下使用呢？</strong><br>观察者可以实现消息的广播，一个消息可以触发多个事件，这是观察者模式非常重要的功能。</p>
<p><strong>使用观察者模式也有个重点问题要解决： </strong><br><strong>广播链的问题</strong><br>如果你做过数据库的触发器，你就应该知道有一个触发器链的问题，比如表 A 上写了一个触发器，<br>内容是一个字段更新后更新表 B 的一条数据，而表 B 上也有个触发器，要更新表 C，表 C 也有触发器…,完蛋了，<br>这个数据库基本上就毁掉了！我们的观察者模式也是一样的问题，一个观察者可以有双重身份，即使观察者，<br>也是被观察者，这没什么问题呀，但是链一旦建立，这个逻辑就比较复杂，可维护性非常差，根据经验建议，<br>在一个观察者模式中多出现一个对象既是观察者也是被观察者，也就是说消息多转发一次（传递两次），这还是比较好控制的。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电影无间道很多人都看过，讲的是关于黑社会与警局卧底的故事。&lt;br&gt;我们今天就聊一下无间道和面向对象的观察者模式到底有什么关系。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//被观察者
public interface Observable
{
    void notifyEveryb
    
    </summary>
    
      <category term="架构设计" scheme="http://wuage.me/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="面向对象，架构设计" scheme="http://wuage.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>PHP结合Linux的cron命令实现定时任务</title>
    <link href="http://wuage.me/2016/08/22/linux-cron/"/>
    <id>http://wuage.me/2016/08/22/linux-cron/</id>
    <published>2016-08-21T16:00:00.000Z</published>
    <updated>2016-08-22T14:59:36.750Z</updated>
    
    <content type="html"><![CDATA[<p>PHP死循环 来处理定时任务的效率是很低的。（众多网友评价）<br>大家都建议使用Linux内置的定时任务crontab命令来调用php脚本来实现。</p>
<p><strong>PHP定时任务的两种方法：</strong><br>1、web方式调用php网页，但是这样存在安全问题，外部用户同时也可以调用此文件。</p>
<pre><code>*/1 * * * * /usr/bin/wget -q -O temp.txt http://wan.coolxap.cn/cron
</code></pre><p>2、用php-cli 模式来调用 php脚本，cli是以一种命令行模式来执行php脚本</p>
<pre><code>* * * * * /usr/bin/php -f /root/test.php &gt;&gt; test.log
</code></pre><p>使用crontab -e添加任务，在/var/spool/cron下你可以看到一个root文件。</p>
<p>重启服务，使修改 生效</p>
<pre><code>service crond restart
</code></pre><p>crontab最细的粒度是分钟，但可以起多个任务+休眠来达到模拟 以秒为单位的任务。</p>
<pre><code>* * * * * /bin/date &gt;&gt; /tmp/date.txt
* * * * * sleep 10; /bin/date &gt;&gt; /tmp/date.txt   
* * * * * sleep 20; /bin/date &gt;&gt; /tmp/date.txt
* * * * * sleep 30; /bin/date &gt;&gt; /tmp/date.txt
* * * * * sleep 40; /bin/date &gt;&gt; /tmp/date.txt
* * * * * sleep 50; /bin/date &gt;&gt; /tmp/date.txt
</code></pre><p>列举个真实场景：</p>
<pre><code>*/1 * * * * /usr/bin/wget --spider http://wan.coolxap.cn/cron/closeinvalidlive
0 0 27 * * /usr/bin/wget --spider http://wan.coolxap.cn/cron/magicdistributed
0 0 26 * * /usr/bin/wget --spider http://wan.coolxap.cn/cron/guildassessment
0 0 27 * * /usr/bin/wget --spider http://wan.coolxap.cn/cron/guildprizestatement
</code></pre><p><strong>当定时任务不起作用</strong><br>定时任务，里面执行php脚本。<br>发现不能直接执行，需要切换到www用户来执行php脚本，<br>否则，脚本所做的操作都是以 root 的权限来执行的，比如创建文件目录 和 下载的图片都是属于 root 用户组。<br>直接导致到的问题是，web网页用户由于权限不足就无法对该目录进行操作，比如root创建的目录，web用户无法在该目录上传图片。</p>
<p><strong>解决方案如下：</strong></p>
<pre><code>!/bin/sh
</code></pre><p>切换到www用户来执行命令</p>
<pre><code>su www &quot;-c cd /alidata/www/wwwroot/17xap/e/caidiscuz/ &amp;&amp; /aliyun/webserver/php5.2.17/bin/php pushnews2.php -9 -u&quot;
</code></pre><p>另外解决图片下载时发现的一个解决问题的小技巧。<br>用接口的形式来访问某个php文件时，发现下载图片失败，提示权限不足 无法在该目录做图片存储操作。<br>然后检查目录的权限是wr-wr-wr 0666，理论上是支持目录的读写。但为什么不能做图片下载操作呢？<br>因为没有x权限就无法在该目录下执行任何命令，包括mkdir、ls等。创建图片不仅需要 w权限还需要x权限。<br>改为wrx-r-xr-x 0755权限后就能正常下载图片。</p>
<p>解决问题的技巧是先给足0777权限后，待问题解决了，确定是目录权限不足导致脚本无法正常运行的时候，再把目录的权限收回来，逐步提高权限。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP死循环 来处理定时任务的效率是很低的。（众多网友评价）&lt;br&gt;大家都建议使用Linux内置的定时任务crontab命令来调用php脚本来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PHP定时任务的两种方法：&lt;/strong&gt;&lt;br&gt;1、web方式调用php网页，但是这样存在
    
    </summary>
    
      <category term="后端开发" scheme="http://wuage.me/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Linux，定时任务，后端开发" scheme="http://wuage.me/tags/Linux%EF%BC%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>架构设计的演变历程</title>
    <link href="http://wuage.me/2016/08/21/architecture-evolution%20/"/>
    <id>http://wuage.me/2016/08/21/architecture-evolution /</id>
    <published>2016-08-20T16:00:00.000Z</published>
    <updated>2016-08-21T10:30:56.344Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、无框架结构，直接调用底层API</strong><br>以往是底层平台（操作系统）提供API让上层APP去调用。<br>这样的软件控制权在APP上。举例 APP调用了平台的函数 Fun1，那么平台要对Fun1进行维护不敢随意改变这个函数，系统的更新成本大，上层APP越多，维护成本越大，导致到平台被局限。</p>
<p><strong>2、单层框架结构</strong><br>为了让系统开发者取得控制权，后来架构师们建造了一种框架结构。<br>APP开发者在这个框架的结构基础上开发自己的APP。<br>单层结构的模型是下图所示：<br><img src="http://o94lqiatj.bkt.clouddn.com/architecture-evolution-4.png" alt=""></p>
<p>除了一部分平台的API仍然是由APP所调用外，更多是由框架反向调用APP来驱动整个APP的运行，框架定义出接口与基类，APP基础基类写出具象类，框架通过调用接口来实现对APP的反向调用，这也是IoC原理的核心。</p>
<p><strong>3、复合型框架</strong><br>为了满足更多元化的软件业务需求的开发，从单层框架基础上延伸除了复合型框架，<br>大框架和平台是系统开发者来开发，小框架可以系统开发者或者第三方厂商开发，比如游戏引擎，小框架是可以根据不同业务来选型，APP在这种大小框架结合的情境下开发大大的降低了开发难度，加快了开发速度。</p>
<p><img src="http://o94lqiatj.bkt.clouddn.com/architecture-evolution-2.png" alt=""></p>
<p><strong>4、双层框架</strong><br>为了进一步完善框架，即平衡APP的开发速度也要提高APP的运行速度。<br>那么结合Java和C++两种语言的特性来构建这个框架，Java是应用层级与APP开发者最亲近，它是负责简化APP开发来设计的，从语言特性来说Java是更简单，容易被APP开发者所使用，C++是更运行性能高效，是负责性能担当，它与平台更亲近。<br>两者结合，使得APP的开发速度快，且运行速度快。</p>
<p><img src="http://o94lqiatj.bkt.clouddn.com/architecture-evolution-1.png" alt=""></p>
<p><strong>5、Android的框架</strong><br>Android的框架就是采用上面的双层复合型框架的方式来构建的。其实现在很多框架都采用这种方式来构建。</p>
<p>举例个例子来了解下Android的底层框架原理。<br>1、Android的四大组件，Activity、service、BroadcastReceiver、ContentProvider。</p>
<p>他们的作为基类是由框架所定义的，APP的开发者想要用组件的功能只能是写子类来继承使用。如定义 myActivity，由框架所调用 new myActivity 创建出对象并被调用 onCreate方法来创建窗体页面。<br>模拟一下框架的实现：<br>Activity object = new myActivity();<br>object.onCreate();<br>哪有人会疑惑，框架的代码是在这个APP开发之前就有了，那么框架代码怎么会有myActivity这个类，myActivity这个类明明是APP开发者来写的，这个名称系统开发者不可能提前知道。<br>这就归功于 AndroidManifest.xml文档，Mani文档里面要求开发者把自己定义的Activity的名称写上。<br>在APP执行阶段（run-time）Android框架就会读取开发者所写的Mani的内容，从而得知到开发者所写子类的名称，就能创建出这些应用子类的对象。<br>如下图所示：</p>
<p><img src="http://o94lqiatj.bkt.clouddn.com/architecture-evolution-5.png" alt=""></p>
<p>2、组件与组件之间的沟通：<br>从上面大家知道组件的子类虽然由APP开发者所写，但却由框架所创建，<br>同样，组件中的通信也是由框架所负责，框架是组件间沟通的桥梁。而沟通的介质是intent，中文翻译过来是意图，实际是跟信封一个道理。<br>你给远在他方的女朋友寄一封信，你只要按照邮局规定的格式来写这封信，比如写好寄信人信息，收信人信息，和信的内容，最后投递到邮局，最终通过邮局来把这一封信寄到你女朋友手里。<br>同样APP开发者只需要按照格式写好Intent交给框架，而至于框架怎么把Intent交给对方你就不需要关注。</p>
<p>如下图所示：</p>
<p><img src="http://o94lqiatj.bkt.clouddn.com/architecture-evolution-3.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1、无框架结构，直接调用底层API&lt;/strong&gt;&lt;br&gt;以往是底层平台（操作系统）提供API让上层APP去调用。&lt;br&gt;这样的软件控制权在APP上。举例 APP调用了平台的函数 Fun1，那么平台要对Fun1进行维护不敢随意改变这个函数，系统的更新成本大
    
    </summary>
    
      <category term="架构设计" scheme="http://wuage.me/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="架构设计" scheme="http://wuage.me/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向对象--抽象方法的理解</title>
    <link href="http://wuage.me/2016/08/21/oop-abstract-method/"/>
    <id>http://wuage.me/2016/08/21/oop-abstract-method/</id>
    <published>2016-08-20T16:00:00.000Z</published>
    <updated>2016-08-21T09:49:03.889Z</updated>
    
    <content type="html"><![CDATA[<p>首先是将需求中容易变化与不变化的部分进行分离。</p>
<p>不容易变化的提取到父类（抽象类），容易变化的放在子类（具象类）实现。</p>
<p>比如：<br>举例一：<br>要实现 1+2+3+…+N 算法。</p>
<p>那么可以在父类实现加法部分，然后父类执行 getCount抽象方法，获取子类的N</p>
<p>举例二：<br>实现 1+2+3+…+N  和 1<em>2</em>3<em>…</em>N 等多种以N为结尾的算法。</p>
<p>父类拥有N这个值，创建多个子类，每个子类实现不同的算法，子类获取父类N的值进行算法运算，最终以 getValue的抽象方法把计算后的值返回到父类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先是将需求中容易变化与不变化的部分进行分离。&lt;/p&gt;
&lt;p&gt;不容易变化的提取到父类（抽象类），容易变化的放在子类（具象类）实现。&lt;/p&gt;
&lt;p&gt;比如：&lt;br&gt;举例一：&lt;br&gt;要实现 1+2+3+…+N 算法。&lt;/p&gt;
&lt;p&gt;那么可以在父类实现加法部分，然后父类执行 get
    
    </summary>
    
      <category term="面向对象" scheme="http://wuage.me/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="面向对象" scheme="http://wuage.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>以面向对象的角度理解android的架构设计</title>
    <link href="http://wuage.me/2016/08/21/oop-android-EIT/"/>
    <id>http://wuage.me/2016/08/21/oop-android-EIT/</id>
    <published>2016-08-20T16:00:00.000Z</published>
    <updated>2016-08-21T09:53:20.092Z</updated>
    
    <content type="html"><![CDATA[<p>高焕堂老师的android面向对象视频，讲的非常好。 <a href="http://www.maiziedu.com/u/2021/" target="_blank" rel="external">http://www.maiziedu.com/u/2021/</a><br>其中他对 面向对象的理解，延伸出了EIT的概念。</p>
<p>E表示父类<br>I表示接口<br>T表示子类</p>
<p>E是控制点，透过I来控制T。</p>
<p>用代码来表示用两种方式：<br>第一种方式：</p>
<pre><code>public class Parent
{
    public void Fun()
    {
    doSomething();
    }

    public abstract void onDoSomething()
    {
    }
}

public class Child extend Parent
{
    public void onDoSomething()
    {
      //具体实现；不同的子类实现 这里的代码有不同的处理逻辑
    }
}

public class  Main
{
    public void static main
    {
        Parent object = new Child();
        object . Fun();
    }
}
</code></pre><p>子类集成父类，实现了某个抽象方法。<br>Main类创建对象，来达到父类调用子类的执行流程。  这也叫做 IOC，依赖倒置。</p>
<p>这样系统开发者就能将 Child  类的实现很好的隐藏起来，只对外提供 IChild。</p>
<p>Child 的内容可以随意替换，可以改为：</p>
<pre><code>public class Sun implements IChild
{
    public void onDoSomething()
    {
      //具体实现
    }
}

public class ChildFactory
{
    public static IDoSomething NewChild()
    {
        return new Sun();
    }
}
</code></pre><p>系统程序的代码逻辑改了，但是客户端代码就不用动。</p>
<p>架构师能够利用EIT能设计非常好的架构，<br>其中E和I是架构师来写的，T是客户端程序员写的。</p>
<p>E和I的作用在于复用。<br>T的作用在于拥抱变化。</p>
<p>举个例子，比如说：<br>吃火锅。</p>
<p>在客人来之前，火锅店老板已经把桌子和桌子中央的火锅架（凹下去的那个）弄好。  （架构师）<br>客人来之后，客人选择吃什么汤底，普通锅（中间没有挡板）还是鸳鸯锅。选择之后，就能把火锅盘放到火锅架上。（客户端程序员）</p>
<p>假如说，桌子火锅架和火锅都是融合在一体的，其中只有一个桌子是鸳鸯锅，那么来了三个客人都想吃鸳鸯锅。<br>这样就不能同时符合三个客人的需求了。</p>
<p>再举例：<br>汽车的引擎就是E和I<br>轮胎就是T</p>
<p>汽车在不同环境 换 不同的轮胎，能够驾驶在沙漠、草原、高速路。</p>
<p>在软件系统中也是一样道理。<br>EIT的设计使得系统变得分离，达到最终的目的是复用。E和I是复用的。</p>
<p>从大的系统架构来分析。<br>框架就是 E和I<br>插件就是 T</p>
<p>按照这样的架构模式，插件是可插拔的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高焕堂老师的android面向对象视频，讲的非常好。 &lt;a href=&quot;http://www.maiziedu.com/u/2021/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.maiziedu.com/u/2021/&lt;/a&gt;&lt;b
    
    </summary>
    
      <category term="面向对象" scheme="http://wuage.me/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="面向对象" scheme="http://wuage.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向对象--类模板的理解</title>
    <link href="http://wuage.me/2016/08/21/oop-class-template/"/>
    <id>http://wuage.me/2016/08/21/oop-class-template/</id>
    <published>2016-08-20T16:00:00.000Z</published>
    <updated>2016-08-21T09:49:03.148Z</updated>
    
    <content type="html"><![CDATA[<p>template是class的模板，用template可以生成类的形态。<br>class是object的模板，用class可以实例化出具体的对象。</p>
<pre><code>class Person&lt;T&gt;
{
    private T age;
}


Person&lt;int&gt; p = new Person&lt;int&gt;();
</code></pre><p>编译的时候先用 Person<int> 替换成class，然后用这个 class 生成具体对象。</int></p>
<p>缸&lt;米&gt;<br>可以装米的缸</p>
<p>缸&lt;水&gt;<br>可以装水的缸</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;template是class的模板，用template可以生成类的形态。&lt;br&gt;class是object的模板，用class可以实例化出具体的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Person&amp;lt;T&amp;gt;
{
    private T age;
}



    
    </summary>
    
      <category term="面向对象" scheme="http://wuage.me/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="面向对象" scheme="http://wuage.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>漫谈项目设计&amp;重构&amp;性能优化</title>
    <link href="http://wuage.me/2016/08/20/talk-code/"/>
    <id>http://wuage.me/2016/08/20/talk-code/</id>
    <published>2016-08-19T16:00:00.000Z</published>
    <updated>2016-08-21T09:53:50.657Z</updated>
    
    <content type="html"><![CDATA[<p><strong>重构的好处：</strong><br>重构能够改进软件设计，随着项目需求的变更，项目体积的变大早已与最初的设计大相径庭，代码结构变得凌乱、复杂，如果不进行重构，则很难添加新的功能。</p>
<p>1、使项目代码更容易理解<br>很多情况下是由于项目赶进度和不注重质量导致的。那么通过重构可以帮助代码维持自己该有的形态。<br>项目开始的时候，设计并没有考虑到方方面面，因为你不可能预测到后面的所有需求。同时你也不能把每个功能都做预留，做成灵活可变，如果最后你预测失败，那么意味着你所做的灵活性是多余的，浪费了时间且增加了开发难度。这种情况叫做过度设计。<br>为了避免这样的情况，项目之初只做必要的设计。随着项目的变更，软件结构需要重新调整。通过重构可以改良最初的设计，使得项目符合最新的需求。</p>
<p>经验告诉我们，当下只管建造可运行的最简化的系统，至于灵活而复杂的设计，多数时候你都不会需要它。</p>
<p>2、帮助你找到BUG<br>重构需要你深入代码结构，这样使得你搞清楚程序结构的同时，找出隐含的BUG。</p>
<p>3、重构提高编码速度<br>重构后的代码，代码结构被改良，良好的设计能够加快开发速度。</p>
<p><strong>重构与性能优化：</strong><br>重构是为了让代码易于理解，你常会做出一些使程序运行变慢的修改。</p>
<p>重构的过程中，不要同时最求优化性能。特别当重构代码优化与性能优化两者出现冲突的时候<br>通常情况下重构会使代码优雅，性能优化为了提高性能不得不采用一些技巧来实现从而有可能使得代码变得复杂<br>而且，有时性能好坏不是单凭感觉出来，多了几个for循环带来的性能下降通常没有你想象中那么大，一定要量化，能测出数据来证明是否由此导致的性能下降。<br>此时要注意我们的目的是重构，重构的手法可能会使得软件性能有所下降，也应该往下执行。<br>性能优化属于另外一个关注点，等重构完成后，项目设计良好，此时再去做性能优化也更容易。</p>
<p>若仅凭感觉来决定说为了提高性能而放弃重构代码，这是一个错误的想法。</p>
<p>正确的做法是：<br>首先写出可运行的软件，然后调整它以求获得更快的速度。</p>
<p>如果当你在开发的过程中时刻追求软件的性能，首先会导致开发难度增加、开发时间变长。同时大多数情况下来分析，你会发现你花费的大部分时间都是在调整一些小部分的代码上以追求性能的增加，实际上这小部分代码最终被执行的概率没有你想象中的那么频繁。这意味着你大部分时间做的是无用功。<br>你所做的性能优化是你臆想出来的。<br>只有当你做出可运行的项目，并且对整个项目结构了解清楚之后，知道性能瓶颈在哪，有针对性的进行优化，通常会有意想不到的收获。</p>
<p><strong>何时重构：</strong><br>重构可以随时进行，不一定要专门腾出时间来进行重构。（当然，你也可以这么做，前提是团队的意见是一致，并征得老板同意，说服老板重构能够改良设计不仅代码质量提高同时加快开发速度。）<br>但注意一定要将重构和添加功能的两种状态进行划分，在重构的时候不要添加功能。否则你不知道BUG是重构时导致还是添加功能时导致，增加重构的难度。<br>这两种状态可以来回切换，但不能重叠。</p>
<p><strong>何时不该重构：</strong><br>项目已近最后期限，因为已经没有足够的时间重构</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;重构的好处：&lt;/strong&gt;&lt;br&gt;重构能够改进软件设计，随着项目需求的变更，项目体积的变大早已与最初的设计大相径庭，代码结构变得凌乱、复杂，如果不进行重构，则很难添加新的功能。&lt;/p&gt;
&lt;p&gt;1、使项目代码更容易理解&lt;br&gt;很多情况下是由于项目赶进度和不
    
    </summary>
    
      <category term="架构设计" scheme="http://wuage.me/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="架构设计" scheme="http://wuage.me/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>种一棵树最好的时间是十年前，其次是现在。</title>
    <link href="http://wuage.me/2016/08/07/never-give-up/"/>
    <id>http://wuage.me/2016/08/07/never-give-up/</id>
    <published>2016-08-06T16:00:00.000Z</published>
    <updated>2016-08-21T09:22:39.256Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong><br>最近经常被朋友问到的两个问题。</p>
<blockquote>
<p>问题一： “从事IT工作3年了，做技术好累啊，是不是做到30岁就不能继续往下做啊？”<br>问题二： “我已经30岁了，还能不能学编程？”</p>
</blockquote>
<p>我给出的答案是：</p>
<blockquote>
<p>只要你兴趣还在，可以一直做，什么时候都不会晚；<br>种一棵树最好的时间是十年前，其次是现在。</p>
</blockquote>
<p>本人目前在IT行业工作了6年，做过大大小小的项目，虽然跟网上那些大牛比还差很远。<br>但也确实经历过同样困惑，也迷茫过，踩过很多坑，今后也会继续踩。<br>所以关于这一类问题，也有心得体验，在此算是做个人分享吧。</p>
<p>（本人文笔不好，写的都是流水账，凑合着看吧）</p>
<p>==========================请无视我，我是一条分线==========================</p>
<p><strong>IT这个行业：</strong><br><strong>IT门槛低：</strong><br>只要大学是这个专业或者非专业出身经过培训出来的就能进入这个行业。（当然，我并没有歧视IT培训这个意思，我也接触过不少IT培训出来的朋友，同样有很多牛人，包括身边的同事）</p>
<p><strong>IT福利好：</strong><br>前几天国内关于各行业平均薪资做了统计，其中金融是第一位，IT紧随其后，可谓钱景不错。<br>市场环境相对公平，IT行业的公司，内部氛围还是不错的，相对自由平等。只要你努力，为公司为团队体现出应有的价值，那么福利和晋升机会都随之而来。（做政府项目或者国企性质的IT公司有些例外，这些公司大多是以关系和资源为核心而并非以技术为核心，不在本文讨论范围内）</p>
<p>总的来说，对于我们这些大多数普通家庭出身的人来说，进入IT领域是一个能够实现屌丝逆袭的好选择。</p>
<p><strong>工作：</strong><br>提升个人能力的四个步骤。学习、实践、总结、分享。</p>
<p><strong>学习：</strong><br>工作六年基本能做到每月花100块买来书，书已经成为了我的生活调味剂，看书已经成为一种习惯。<br>对于技术要保持好奇心，时刻关注最新的行业动态，发展趋势。<br>寻找更高效的方法，更便捷的工具，来提高工作效率，减少加班。给自己留出更多的私人空间和时间，来约朋友吃饭聊天，来陪陪家里人。<br>你工作的做前端的，那么你可以尝试下后端开发。你如果是做后端的，那么可以尝一下前端。<br>你做android的，那么你可以尝试下iOS。<br>你做客户端native的，可以尝试下跨平台的各个方案，例如react native。<br>不要把自己局限在一个领域，要横向拓展技能点。思维拓展之后，有助于你深入。找到了共通点，解决问题的多个思路。</p>
<p><strong>实践：</strong><br>掌握的知识不在于，你硬盘了塞满了教学视频、浏览器收藏夹装满了课程网址、书柜里堆满了书，而在于你能否把学到的知识运用的实际的工作。<br>技术最终的落脚点是解决现实生活中的问题。</p>
<p><strong>总结：</strong><br>有句话说的好，浓缩的是精华。<br>比如说看书，你可以延展阅读范围，不局限于你的本专业，可以是技术、运营、心理、管理，只要你有兴趣都可以去看。但是看了之后最好能对它们进行归类总结，把学到知识用到工作当中。<br>做技术同样，你可以尝试做前端、后端、嵌入式都没问题，不要纠结选择哪个方向更好，重点是去学去动手，积累经验，提升你解决问题的能力。<br>例如本人写这篇日志也是总结&amp;分享的一个过程。<br>从现在开始，利用各种云笔记工具，随时随地记录你的想法。</p>
<p><strong>分享：</strong><br>检验你是否掌握了一个技能点的好方法就是，你能不能够用自己的语言来描述清楚。<br>比如说：你能否跟别人讲明白，你对阻塞和非阻塞，异步、同步的理解，用你自己的理解结合你以往的项目中有关的技术点来展开。</p>
<p>从2015年开始参加各种线下的技术沙龙，认识了很多行业内的大牛。那种XX的交流，思想的碰撞，能带给你很多意想不到的收获。<br>因此我树立了一个近期目标，就是希望能够有一天站在在台上跟大家分享。然而机会还没到来的时候，也就说明我现在暂时还没有能力去做这个事，那么我现在需要继续修炼内功，沉淀，提升文笔和表达能力。<br>有人说花这么大的精力去做这些事会不会影响工作，我却认为利用业余时间做这些事情反倒会对你的工作带来好处。<br>第一点个人能力的提升，对公司来说就是战斗力的提升。<br>第二点你的交际范围扩大了，同时你的人脉也成为了公司的资源。</p>
<p><strong>创业：</strong><br>360 CEO周鸿祎说过一句话，创业的终极目标不是财富，而是一种修行，重塑自我的修行。<br>前两年爬过泰山和华山，特别高需要爬7、8个小时。回忆起来给我最大的感觉是，整个过程就是累，脚都要麻了，几度想要放弃，是队员的鼓励、是渴望登顶的执着，使大家坚持到最后。<br>我是14年初进入互联网创业，这两年给我带来了不一样的体验，能够有机会跟优秀的人一起工作是一件很nice的事情。</p>
<p>同样，创业是风险大的投资，成功的概率不到1%，如果害怕失败就不要创业。那么面对创业失败要怎么调整心态变得及其重要。<br>仍然以登山举例：<br>千辛万苦你终于爬上山顶，往下看到的风景很美，但你不能在此逗留太久，因为山顶的夜晚特别冷，赶在天黑之前下山吧，别舍不得。<br>你若不下山，又怎么能去爬另外一座山呢。因此，你需要学会坦然面对得与失。</p>
<p><strong>生活：</strong><br>关于生活的四个方面：衣食住行。</p>
<p><strong>衣：</strong><br>以前我也不怎么注意穿衣打扮，码农清一色标准就是格子体恤+牛仔裤。<br>几年前开始在某宝、某猫网站逛，买到不合适的就扔，然后继续买，于是买买买、扔扔扔，不要舍不得花钱，一年下来也就一两千（我买的衣服都很便宜），逐渐形成自己的穿衣风格，对着镜子看，你会发现，我去，老子比以前帅多了。<br>有人会说：马云和那谁谁谁穿着很随便，人家都当首富，你穿这么好又不见得你当首富去。</p>
<p>人家是本身有能力然后成为成功人士，只不过个人爱好在于穿衣打扮。<br>而不是因为他不注重穿衣打扮，而成为成功人士。<br>这是两个概念，请不要歪曲事实。不要迷信这些网上的流言，不要老拿别人一个点放大来说。<br>话说，谁会拒绝与那些穿衣得体的人交朋友。因此，在你消费能力范围内去改善你的外在形象，把逼格提高吧。</p>
<p><strong>食：</strong><br>有条件允许的情况下去学一下烹饪，会做饭的男生很贴心、也是你的技能加分点。</p>
<p><strong>住：</strong><br>尽量搬往公司近一点的地方，以前我也有一个观念是，北漂嘛，离公司远一点上下班挤公交挤地铁吃点苦没关系，锻炼毅力嘛，在车上还能看个技术视频学习学习。实际上后来发现这个想法很幼稚，疲惫的身躯。从而将这种负面情绪发泄在工作上。<br>于是我搬得离公司越来越近，从以前的挤公交到骑自行车十几分钟到走路几分钟。（现在直接是住在公司旁边的小区）</p>
<p><strong>行：</strong><br>旅游，去过国内很多个城市，也即将办理护照计划到国外走走。<br>不要老抱怨程序员交友圈子小把不到妹子，不是行业的缘故，是你把自己圈在这里面了。<br>走万里路，才能回到内心深处。读万卷书，才能看清皓月繁星。</p>
<p><strong>回应本文开始提到的问题：</strong><br>30岁后是否还能继续做技术。<br>首先，答案是肯定的。互联网的行业很深，足以。你看阿里的技术大神蔡景现（花名多隆），人家做了那么多年技术从淘宝最初的LAMP一两台主机网站架构到现在的大数据高并发的级分布式电商系统，而且他还能继续往下做，而且越做越牛。<br>技术只是一个切入点，让你进入到IT行业。<br>往下可以做有很多个细分领域，电商、O2O、金融、物联网、直播 等。<br>我也即将30了，人家说三十而立，30岁以前以往我把青春和热血放在，30岁过后我仍然会投身于互联网行业的第一线。<br>这个奋斗过程中会碰到各种牛人，相互交流，共同进步，共同把国内的互联网环境推向更好的未来。</p>
<p><strong>结尾：</strong><br>以高晓松老师的名言来做个Ending。人生不是眼前的苟且，还有诗和远方的田野。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br&gt;最近经常被朋友问到的两个问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;问题一： “从事IT工作3年了，做技术好累啊，是不是做到30岁就不能继续往下做啊？”&lt;br&gt;问题二： “我已经30岁了，还能不能学编程？”&lt;/p&gt;
&lt;/b
    
    </summary>
    
      <category term="程序人生" scheme="http://wuage.me/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="程序人生" scheme="http://wuage.me/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android从入门到放弃-Service</title>
    <link href="http://wuage.me/2016/08/06/android-Service/"/>
    <id>http://wuage.me/2016/08/06/android-Service/</id>
    <published>2016-08-05T16:00:00.000Z</published>
    <updated>2016-08-21T09:20:45.236Z</updated>
    
    <content type="html"><![CDATA[<p>前面说到了四大组件中的Activity，今天说一下Service。<br>四大组件都是由Android系统底层调用的，他们都是继承于各自的基类。<br>如你所写的MyActivity是继承于Activity，MyService继承于Service。</p>
<p>Google当初这么设计的原因在于，把系统核心的部分进行抽象，具体的部分由应用开发者来填补，这样能满足不同的业务场景下的系统构建。<br>从哲学来说是留空，空就是一切。</p>
<p>大家要知道你想调用某个类的方法，你首先得知道这个类名是什么，才能实例化它调用它的方法。<br>那么，有个疑问，这些Android的基础架构是提前写好的，MyActivity具体类是应用开发者后来才写的，系统怎么知道我写的这个类名叫MyActivity呢？<br>答案是通过 AndroidManifest.xml。<br>大家创建四大组件需要把自己实现类的类名写到这个xml上，然后编译时最终通过反射的机制来获取到类名。系统得到了类名之后，能够实例化这个对象，并调用它的方法。<br>并且一部分方法是通过IoC的机制来进行调用的，比如大量 onXXX() 的方法就是系统调用子类的具体实现。</p>
<p>好了前面说了四大组件如何与Android系统之间的关系。<br>下面回到正题，说一下Service是如何使用。</p>
<p>首先，我们需要实现一个Service具体类，比如MyService，它继承于Service。<br>Activity通过startService来启动Service，并创建ServiceConnection 来管理 Activity与Service之间的连接，这个有点类似于B/S结构的概念。MyService实现一个onBinder方法，这个方法是在Activity启动Service时由系统来回调，系统将Service创建的Binder对象引用传递到Activity，然后Activity就通过Binder来调用Service的方法。<br>比如让Service启动一个子线程做网络请求，处理好了之后，Service要通知Activity更新界面。</p>
<p>其中有一种方式是通过接口的形式来实现。Activity实现接口，Service通过调用接口方法回调到Activity，Activity再通过Handler来发送消息更新界面。</p>
<p>以上基本是Service最简单的使用说明。</p>
<p>有人会提问，既然主线程可通过启动子线程来执行后台任务，为什么还需要Service呢？<br>原因在于系统赋予了Service比主线程的Activity具有更高的优先级。那么当系统资源不足的时候，要做垃圾回收，那么Activity下的多线程很有可能被回收掉，那么线程没执行完的事情就会停止掉。而Service具有更高的优先级，以它来启动的线程不轻易被回收。</p>
<p>GitHub地址： <a href="https://github.com/wuzhuojun/firstcode/tree/master/fcode4" target="_blank" rel="external">https://github.com/wuzhuojun/firstcode/tree/master/fcode4</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面说到了四大组件中的Activity，今天说一下Service。&lt;br&gt;四大组件都是由Android系统底层调用的，他们都是继承于各自的基类。&lt;br&gt;如你所写的MyActivity是继承于Activity，MyService继承于Service。&lt;/p&gt;
&lt;p&gt;Googl
    
    </summary>
    
      <category term="android" scheme="http://wuage.me/categories/android/"/>
    
    
      <category term="android" scheme="http://wuage.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android从入门到放弃</title>
    <link href="http://wuage.me/2016/08/06/android-directory/"/>
    <id>http://wuage.me/2016/08/06/android-directory/</id>
    <published>2016-08-05T16:00:00.000Z</published>
    <updated>2016-08-21T09:20:45.891Z</updated>
    
    <content type="html"><![CDATA[<p>Android入门练手的demo<br>传送门：<a href="https://github.com/wuzhuojun/firstcode" target="_blank" rel="external">https://github.com/wuzhuojun/firstcode</a></p>
<p>以下是项目的目录：</p>
<p>1、fcode1<br>Activity 与 Fragment的练习</p>
<p>2、fcode2<br>butterknife 注解的使用</p>
<p>gradle设置：</p>
<pre><code>classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;
apply plugin: &apos;android-apt&apos;
</code></pre><p>需要增加库：</p>
<pre><code>compile &apos;com.jakewharton:butterknife:8.1.0&apos;
apt &apos;com.jakewharton:butterknife-compiler:8.1.0&apos;
</code></pre><p>资料：<br><a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="external">http://jakewharton.github.io/butterknife/</a></p>
<p>3、fcode3<br>获取网络数据<br>多线程的使用 Thread &amp; AsyncTask<br>发消息到主线程更新UI元素</p>
<p>4、fcode4<br>Service的使用<br>Activity 与 Service 的相互通信。<br>Service 通过 回调的方式来通知 主线程更新UI元素</p>
<p>5、fcode5<br>Service 通过 广播的方式来通知 主线程更新UI元素<br>每次用Service都需要另外启动线程来处理耗时操作。而IntentService对此做了封装，不需要每次另外启动线程。</p>
<p>6、fcode6<br>AIDL</p>
<p>7、fcode7<br>OkHttp &amp; gson 的使用</p>
<p>需要增加库：</p>
<pre><code>compile &apos;com.squareup.okhttp:okhttp:2.4.0&apos;
compile &apos;com.google.code.gson:gson:2.4&apos;
</code></pre><p>资料：<br><a href="http://square.github.io/okhttp" target="_blank" rel="external">http://square.github.io/okhttp</a><br><a href="https://github.com/google/gson" target="_blank" rel="external">https://github.com/google/gson</a></p>
<p>8、fcode8<br>viewpager</p>
<p>引入的库：<br>compile ‘com.android.support:design:23.2.1’</p>
<p>修改样式：</p>
<pre><code>G:\AndroidTestWork\fcode8\app\src\main\res\values\styles.xml
&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;
&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
</code></pre><p>9、fcode9<br>ListView的使用</p>
<p>10、fcode10<br>RecyclerView的使用</p>
<p>需要增加库</p>
<pre><code>compile &apos;com.android.support:recyclerview-v7:23.4.0&apos;
</code></pre><p>资料：<br>RecyclerView 可以做各种复杂的列表界面<br><a href="https://github.com/cymcsg/UltimateRecyclerView" target="_blank" rel="external">https://github.com/cymcsg/UltimateRecyclerView</a><br><a href="https://github.com/lucasr/twoway-view" target="_blank" rel="external">https://github.com/lucasr/twoway-view</a></p>
<p>使用图片缓存 Fresco<br><a href="http://fresco-cn.org/docs/index.html" target="_blank" rel="external">http://fresco-cn.org/docs/index.html</a></p>
<p>图片缓存开源组件比较：<br><a href="http://www.cnblogs.com/younghao/p/5088299.html" target="_blank" rel="external">http://www.cnblogs.com/younghao/p/5088299.html</a><br><a href="http://www.trinea.cn/android/android-image-cache-compare" target="_blank" rel="external">http://www.trinea.cn/android/android-image-cache-compare</a></p>
<p>11、fcode11</p>
<p>RecyclerView 的第三方组件 UltimateRecyclerView；封装了很多功能间隔线、下拉刷新、加载更多、加载动画 等<br>缓存组件 文件/sharepreference；ASimpleCache 是一个为android制定的 轻量级的 开源缓存框架。轻量到只有一个java文件（由十几个类精简而来）。</p>
<p>资料：<br><a href="https://github.com/yangfuhai/ASimpleCache" target="_blank" rel="external">https://github.com/yangfuhai/ASimpleCache</a><br><a href="https://github.com/cymcsg/UltimateRecyclerView" target="_blank" rel="external">https://github.com/cymcsg/UltimateRecyclerView</a></p>
<p>12、fcode12<br>数据库 greenDAO</p>
<p>资料：<br><a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="external">https://github.com/greenrobot/greenDAO</a><br><a href="http://itangqi.me/2015/07/26/orm-greendao-summary/" target="_blank" rel="external">http://itangqi.me/2015/07/26/orm-greendao-summary/</a></p>
<p>13、fcode13<br>广播接受者<br>内容提供者<br>logger</p>
<p>资料：<br><a href="https://github.com/orhanobut/logger" target="_blank" rel="external">https://github.com/orhanobut/logger</a></p>
<p>14、fcode14<br>dagger</p>
<p><a href="http://my.oschina.net/rengwuxian/blog/287892" target="_blank" rel="external">http://my.oschina.net/rengwuxian/blog/287892</a><br><a href="https://github.com/square/dagger" target="_blank" rel="external">https://github.com/square/dagger</a><br><a href="http://blog.csdn.net/ljphhj/article/details/37663071" target="_blank" rel="external">http://blog.csdn.net/ljphhj/article/details/37663071</a><br><a href="http://fanxu.me/post/2013-07-18" target="_blank" rel="external">http://fanxu.me/post/2013-07-18</a></p>
<p>15、fcode15<br>EventBus</p>
<p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">https://github.com/greenrobot/EventBus</a><br><a href="http://www.cnblogs.com/angeldevil/p/3715934.html" target="_blank" rel="external">http://www.cnblogs.com/angeldevil/p/3715934.html</a></p>
<p>16、fcode16<br>RxAndroid 和 Retrofit 结合使用</p>
<p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">https://github.com/ReactiveX/RxAndroid</a><br><a href="https://github.com/lzyzsd/Awesome-RxJava" target="_blank" rel="external">https://github.com/lzyzsd/Awesome-RxJava</a></p>
<p><a href="https://github.com/drakeet/Meizhi" target="_blank" rel="external">https://github.com/drakeet/Meizhi</a><br><a href="https://github.com/rengwuxian/RxJavaSamples" target="_blank" rel="external">https://github.com/rengwuxian/RxJavaSamples</a><br><a href="https://github.com/xcc3641/SeeWeather" target="_blank" rel="external">https://github.com/xcc3641/SeeWeather</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android入门练手的demo&lt;br&gt;传送门：&lt;a href=&quot;https://github.com/wuzhuojun/firstcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/wuzhuojun/firs
    
    </summary>
    
      <category term="android" scheme="http://wuage.me/categories/android/"/>
    
    
      <category term="android" scheme="http://wuage.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android从入门到放弃-线程</title>
    <link href="http://wuage.me/2016/08/06/android-Thread/"/>
    <id>http://wuage.me/2016/08/06/android-Thread/</id>
    <published>2016-08-05T16:00:00.000Z</published>
    <updated>2016-08-21T09:20:46.551Z</updated>
    
    <content type="html"><![CDATA[<p>Android更新UI元素的由主线程来处理，工作线程只能做逻辑运算处理，处理好之后通过Handler发Message给主线程。<br>主线程启动后会建立一个 loop 对象，一直在跑循环，定时检查 MessageQueue，取出Message 进行界面更新。</p>
<p>Google这样设计的目的在于让主线程不需要处理线程安全问题，不需要加解锁，大大提高了APP的性能。 这和windows PC开发的机制是一样。</p>
<p>如果UI线程执行某个逻辑运算时间过长的话，超过5秒，系统就会弹出警告，是否继续等待APP的响应还是关闭。这就是著名的 ANR。<br>因此，所有的耗时操作都应该放在 子线程中运行，比如：访问网络、数据库操作、JSON解析等。</p>
<p>Android常用的线程实现方式有 Thread 和 AsyncTask。</p>
<pre><code>private class MyAsyncTask extends AsyncTask&lt;String, Integer, String&gt; {
    //doInBackground方法内部执行后台任务,不可在此方法内修改UI
    @Override
    protected String doInBackground(String... params) {
        return GetWebData(params[0]);
    }
    //onPostExecute方法用于在执行完后台任务后更新UI,显示结果
    @Override
    protected void onPostExecute(String result) {
        mTvContent.setText(result);
    }
}
</code></pre><p>GitHub地址： <a href="https://github.com/wuzhuojun/firstcode/tree/master/fcode3" target="_blank" rel="external">https://github.com/wuzhuojun/firstcode/tree/master/fcode3</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android更新UI元素的由主线程来处理，工作线程只能做逻辑运算处理，处理好之后通过Handler发Message给主线程。&lt;br&gt;主线程启动后会建立一个 loop 对象，一直在跑循环，定时检查 MessageQueue，取出Message 进行界面更新。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="android" scheme="http://wuage.me/categories/android/"/>
    
    
      <category term="android" scheme="http://wuage.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>坝上草原碰碰车</title>
    <link href="http://wuage.me/2016/06/19/grassland-tour/"/>
    <id>http://wuage.me/2016/06/19/grassland-tour/</id>
    <published>2016-06-18T16:00:00.000Z</published>
    <updated>2016-08-21T09:21:50.657Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言:</strong><br>很多次都下定决心要写博客，有关技能，学习，分享，生活，成长，感悟，之前每次都没坚持下来。<br>借口很多，工作忙没时间，知识储备不够。<br>终究就是太懒的缘故。<br>从今天起，再次下定决心坚持写博客。<br>记得有一个理论是27天形成一个习惯，希望这次能坚持下来。</p>
<p><strong>草原旅游:</strong><br>今天是周末，跟朋友到内蒙边上的草原旅游去了，宽阔的草原蓝天白云，还体验了滑草，骑马。<br>在旅游途中认识了一些很nice的朋友，为旅途增添不少。旅行的其中一个有意思的点在于，不期而遇。去到陌生的地方，认识陌生的人。没有剧本，没有套路，像是在探寻未知的领域。</p>
<p><strong>总结:</strong><br>这几年去了一些城市，北京，天津，济南，西安，南京，杭州，上海…<br>完成了几项任务清单，滑雪，滑冰，爬山，冲浪。<br>人活着最重要的一个意义就是，去做自己喜欢的事情。</p>
<p>本文记于2016年6月19日，回北京的车上。最后来一张行程的合照，<br>明天将会是更好的一天。</p>
<p><img src="http://o94lqiatj.bkt.clouddn.com/mmexport1466317528969.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言:&lt;/strong&gt;&lt;br&gt;很多次都下定决心要写博客，有关技能，学习，分享，生活，成长，感悟，之前每次都没坚持下来。&lt;br&gt;借口很多，工作忙没时间，知识储备不够。&lt;br&gt;终究就是太懒的缘故。&lt;br&gt;从今天起，再次下定决心坚持写博客。&lt;br&gt;记得有一个理论
    
    </summary>
    
      <category term="blog" scheme="http://wuage.me/categories/blog/"/>
    
    
      <category term="旅行" scheme="http://wuage.me/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
</feed>
